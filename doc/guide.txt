CxxTest User Guide
==================
:doctype: article

:numbered!:
[abstract]
Abstract
--------
CxxTest is a unit testing framework for C\++ that is similar in
spirit to http://junit.org/[JUnit],
http://cppunit.sourceforge.net[CppUnit], and
http://xprogramming.com/software.html[xUnit].  CxxTest is easy to
use because it does not require precompiling a CxxTest testing
library, it employs no advanced features of C++ (e.g. RTTI) and it
supports a very flexible form of test discovery.  This documentation
describes CxxTest 4.0, which includes significant enhancements to
the test discovery process, a modern test driver, and new documentation.

:numbered:

Overview
--------

CxxTest is a unit testing framework for C++ that is similar in
spirit to http://junit.org/[JUnit],
http://cppunit.sourceforge.net[CppUnit], and
http://xprogramming.com/software.html[xUnit].  
CxxTest is designed to be as portable as possible;  it does not require

 - RTTI
 - Member template functions
 - Exception handling
 - External libraries (including memory management, file/console I/O, graphics libraries)

In particular, the design of CxxTest was tailored for C\++ compilers
on embedded systems, for which many of these features are not
supported.  However, CxxTest can also leverage standard C++ features
when they are supported by a compiler (e.g. catch unhandled
exceptions).

Additionally, CxxTest supports _test discovery_.  Tests are defined
in C\++ header files, which are parsed by CxxTest to automatically
generate a test runner.  Thus, CxxTest is somewhat easier to use
than alternative C++ testing frameworks, since you do not need to
_register_ tests.

CxxTest is available under the http://www.gnu.org/copyleft/lesser.html[GNU
Lesser General Public] license.
The following are key online resources for CxxTest:

 - http://cxxtest.tigris.org[CxxTest home page]
 - http://cxxtest.tigris.org/servlets/ProjectDocumentListR[Release downloads]
 - http://cxxtest.tigris.org/guide.html[HTML user guide]
 - http://cxxtest.tigris.org/guide.pdf[PDF user guide]

The CxxTest User Guide provides the following documentation:

 - <<gettingStarted,Getting Started>>: Some simple examples that illustrate how to use CxxTest
 - <<testAssertions,Test Assertions>>: The test assertions supported by CxxTest
 - <<cxxtestgen,The CxxTestGen Command>>: Documentation for the +cxxtestgen+ command
 - <<runner,Test Runner Syntax>>: Discussion of command line options for test runners
 - <<samples,Sample Problems>>: Examples that illustrate features of CxxTest
 - <<advanced,Advanced Testing Features>>: Advanced features of CxxTest
 - <<installation,Installation>>: How to install CxxTest
 - <<discussion,Discussion>>: Comments on the past, present and future of CxxTest





[[gettingStarted]]
Getting Started
---------------

Testing is performed with CxxTest in a four-step process:

 1. Tests are defined in C++ header files
 2. The +cxxtestgen+ command processes header files to generate files for the test runner.
 3. Compile the test runner.
 4. Execute the test runner to run all test suites.

CxxTest supports test automation, sharing of setup
and shutdown code for tests, aggregation of tests into collections,
and independence of the tests from the reporting framework.  To
achieve this, CxxTest supports some important concepts that are common to xUnit frameworks (
e.g. http://junit.org/[JUnit], http://cppunit.sourceforge.net[CppUnit], and
http://xprogramming.com/software.html[xUnit]):

test fixture::
   A 'test fixture' represents the preparation needed to perform one or more
   tests, and any associate cleanup actions.  This may involve, for example,
   creating temporary or proxy databases, directories, or starting a server
   process.

/////
test case::
   A 'test case' is the smallest unit of testing.  It checks for a specific
   response to a particular set of inputs.  CxxTest provides a base class,
   +TestCase+, which may be used to create new test cases.
/////

test suite::
   A 'test suite' is a collection of test cases, which represent
   the smallest unit of testing.  A test suite is defined by a class
   that inherits from the +CxxTest::TestSuite+ class, and the tests
   in a test suite are executed together.

test::
    A test is a public member function of a test suite whose name
    starts with +test+, e.g. +testDirectoryScanner()+,
    +test_cool_feature()+ and +TestImportantBugFix()+.

test runner::
   A 'test runner' is a component which orchestrates the execution
   of tests across one or more test suites and provides the outcome
   to the user.

When building test fixtures using +TestSuite+, the +TestSuite.setUp+
and +TestSuite.tearDown+ methods can be overridden to provide
initialization and cleanup for the fixture.  The +TestSuite.setUp+
method is run before each test is executed, and the +TestSuite.tearDown+
method is run after each test is executed.


A First Example
~~~~~~~~~~~~~~~

The following is a simple example of a
test suite with a single test, +testAddition+, which perform two test assertions:
[source,cplusplus]
----
include::examples/.MyTestSuite1_.h[]
----

You use the +cxxtestgen+ script to generate a _test runner_ for test suites in C++ header files:
[source,bash]
----
include::examples/.buildRunner_main.sh[]
----
This command generates the file +runner.cpp+, which can be compiled.
[source,bash]
----
include::examples/.buildRunner_main.sh[]
----
Note that additional compiler flags may be needed to include headers
and libraries that are used during testing.


This runner can be executed to perform the specified tests:
[source,bash]
----
include::examples/.exeRunner_main.sh[]
----
which generates the following output:
[verbatim]
----
include::examples/exeRunner.out[]
----


A Second Example
~~~~~~~~~~~~~~~~

The following header file extends the previous example to
include a test that generates an error:
[source,cplusplus]
----
include::examples/.MyTestSuite2_.h[]
----

The test runner generated by +cxxtestgen+ for this test suite generates the following output:
[verbatim]
----
include::examples/exeRunner2.out[]
----


[[testAssertions]]
Test Assertions
---------------

The following table summarizes the test assertions supported by CxxTest.
<<appendix_A,Appendix A>> provides examples that illustrate the use of these test assertions.

[options="header"]
|====================================================================================
| Macro                                                                 | Description
| <<ts_assert,+TS_ASSERT(_expr_)+>>                                   | Verify +_expr_+ is true
| xref:ts_assert_delta[+TS_ASSERT_DELTA(x,y,d)+]                        | Verify that +abs(x-y) < d+
| xref:ts_assert_differs[+TS_ASSERT_DIFFERS(x,y)+]                      | Verify that +_x != y_+
| xref:ts_assert_equals[+TS_ASSERT_EQUALS(x,y)+]                        | Verify that +_x == y_+
| xref:ts_assert_less_than[+TS_ASSERT_LESS_THAN(x,y)+]                  | Verify that +_x < y_+
| xref:ts_assert_less_than_equals[+TS_ASSERT_LESS_THAN_EQUALS(x,y)+]    | Verify that +_x <= y_+
| xref:ts_assert_predicate[+TS_ASSERT_PREDICATE(P,x)+]                  | Verify +_P(x)_+
| xref:ts_assert_relation[+TS_ASSERT_RELATION(x,R,y)+]                  | Verify +_x R y_+
| xref:ts_assert_same_data[+TS_ASSERT_SAME_DATA(x,y,size)+]             | Verify two buffers are equal
| xref:ts_assert_throws[+TS_ASSERT_THROWS(expr,type)+]                  | Verify that +_expr_+ throws the specified exception type
| <<ts_assert_throws_anything,+TS_ASSERT_THROWS_ANYTHING(expr)+>>     | Verify that +_expr_+ throws an exception
| xref:ts_assert_throws_assert[+TS_ASSERT_THROWS_ASSERT(expr,arg,assertion)+] | Verify type and value of what +_expr_+ throws
| xref:ts_assert_throws_equals[+TS_ASSERT_THROWS_EQUALS(expr,arg,x,y)+] | Verify type and value of what +_expr_+ throws
| <<ts_assert_throws_nothing,+TS_ASSERT_THROWS_NOTHING(expr)+>>       | Verify that +_expr_+ doesn't throw anything
| <<ts_fail,+TS_FAIL(_message_)+>>                                   | Fail unconditionally
| <<ts_trace,+TS_TRACE(_message_)+>>                                 | Print +_message_+ as an informational message
| <<ts_warn,+TS_WARN(_message_)+>>                                    | Print +_message_+ as a warning
|====================================================================================

The test assertions supported by CxxTest are defined as macros,
which eliminates the need for certain templates within CxxTest and
allows tests to catch exceptions.  There are four categories of
test assertions in CxxTest, which are distinguished by their prefixes:

TS_:: These test assertions perform a test. Catch exceptions generated
during testing will cause the test to fail, except for tests that
check for exceptions.

TSM_:: These test assertions perform the same tests as the corresponding
TS_+ assertions, but their first argument is a +const char*+ message
buffer that is printed when the test fails.

ETS_:: These test assertions perform the same tests as the corresponding
TS_+ assertions.  However, these test assertions do not catch
exceptions generated during testing.

ETSM_:: These test assertions perform the same tests as the
corresponding +TS_+ assertions, but (1) their first argument is a
const char*+ message buffer is printed when the test fails, and
(2) these assertions do not catch exceptions generated during
testing.


[[cxxtestgen]]
The CxxTestGen Command
----------------------

The +cxxtestgen+ command processes one or more C++ header files to
generate a test runner.  The +cxxtestgen+ command performs test
discovery by parsing the header files to find test classes, which
inherit from the class +CxxTest::TestSuite+.

The +--help+ option generates the following summary of the +cxxtestgen+ command line options:
[verbatim]
----
include::examples/cxxtestgen.out[]
----
The following section describe illustrate the use of these command line options.


General Options
~~~~~~~~~~~~~~~

The default behavior of +cxxtestgen+ is to send the source for the
test runner to the standard output stream.  The +--output+ (+-o+)
option indicates a filename for the test runner.

The +--world+ (+-w+) option specifies the value of the +CxxTest::RealWorldDescription::_worldName+
variable.  This option also customizes the filename used for XML output files (see below).

The +--include+ option defines a filename that is included in the runner before all other headers.

The +--abort-on-fail+ option forces an abort if a test fails, rather than continuing execution
to the next test.


Test Listener Options
~~~~~~~~~~~~~~~~~~~~~

The test runner behavior is controlled by a _test listener_ class
that is used to define to the +main+ function.  The test listener
class is a subclass of +TestListener+ that receives notifications
about the testing process, notably which assertions failed.  The
--runner+ option is used to specify the test listener that is used
in the test runner.  The following test listeners are defined in
CxxTest:

 +ErrorPrinter+::
    This is the standard error printer, which formats its output to the standard output stream (+std::cout+).
 +StdioPrinter+::
    The same as +ErrorPrinter+ except that it uses +printf+ instead of +std::cout+.
 +ParenPrinter+::
    Identical to +ErrorPrinter+ except that it prints line numbers in parantheses. This is the way Visual Studio expects it.
 +XmlPrinter+::
    Print test results to an XML file.
 +XUnitPrinter+::
    This test listener generates output using both +ErrorPrinter+ and +XmlPrinter+.

ErrorPrinter
^^^^^^^^^^^^

The +--error-printer+ option creates a runner using the +ErrorPrinter+
test listener, and it indicates that the standard library is used
in the test runner.  The +ErrorPrinter+ test listener prints dots
to summarize test execution, along with a summary of the test
results.  For example, the command
[source,bash]
----
include::examples/.buildRunner2_main.sh[]
----
generates the following output:
[source,bash]
----
include::examples/exeRunner2.out[]
----

StdioPrinter
^^^^^^^^^^^^

If your compiler does not support +std::cout+, then the +ErrorPrinter+ test listener cannot be used.
In this case, the +StdioPrinter+ test listener can be used;  it provides the same output as +ErrorPrinter+ but it uses the +printf+ function. For example, the command line:
[source,bash]
----
include::examples/.buildRunner4_main.sh[]
----
generates the following output:
[source,bash]
----
include::examples/buildRunner4.txt[]
----

ParenPrinter
^^^^^^^^^^^^

The +--runner=ParenPrinter+ option creates a similar test runner:
[source,bash]
----
include::examples/.buildRunner3_main.sh[]
----
This test runner generates output that is similar to the +ErrorPrinter+ test listener:
[source,bash]
----
include::examples/buildRunner3.txt[]
----
The only difference is the parentheses used in the output.  This test listener provides a format that can be recognized by Visual Studio.

////
The +StdioPrinter+ makes reference to +stdout+ as the default output
stream. In some environments, the +stdio.h+ header may be defined
but not +stdout+.  The +StdioFilePrinter+ test listener can be used
in this case, though the main() function needs to be adapted to specify the 
stream that is used in output.
////

XmlPrinter
^^^^^^^^^^

The +--runner=XmlPrinter+ option creates a test runner whose output is an XML summary of the test results.  For example, the command:
[source,bash]
----
include::examples/.buildRunner6_main.sh[]
----
generates the following output:
[source,bash]
----
include::examples/buildRunner6.txt[]
----
This XML format is conforms to the XML standard used by other xUnit tools.  Thus, this output can be used as input in other tools, like http://jenkins-ci.org/[Jenkins], to generate test summaries.


XUnitPrinter
^^^^^^^^^^^^

The +XUnitPrinter+ test listener generates output using both the
ErrorPrinter+ and +XmlPrinter+ test listeners.  This allows the
user to interactively view a simple test summary, while simultaneously
generating an XML summary of the test results.  The +--xunit-printer+
option specifies the use of +XUnitPrinter+:
[source,bash]
----
include::examples/.buildRunner7_main.sh[]
----
This test runner generates the following output:
[source,bash]
----
include::examples/buildRunner7.txt[]
----
The default filename for the XML results is +TEST-cxxtest.xml+.  The +--xunit-file+ option can be used to specify an alternative filename.  Additionally, the value of the +--world+ option can be used to specify the filename +TEST-<world>.xml+.


Language Options
~~~~~~~~~~~~~~~~

When +cxxtestgen+ performs test discovery, it also performs checks
to detect whether (1) the standard library is used and (2) exceptions
are used.  These checks configure CxxTest to _not_ assume that these
C++ language features are used when generating the test driver.
Thus, CxxTest can naturally be used with compilers that do not
support these features.

The +cxxtestgen+ command includes several options that override
these checks and define features of C++ that are used by the test
runner.  The +--have-std+ option indicates that the test runner
should use the standard library, and the +--no-std+ option indicates
that the test runner should not use the standard library. The
--have-eh+ options indicates that the test runner should use
exception handling, and the +--no-eh+ indicates that the test runner
should not not use exception handling.  

The +--longlong+ option specifies the type used for long long
integers.

CxxTest test runners depend quite heavily on static initialization
of objects that are used to define and execute tests. The
--no-static-init+ option can be used to avoid static initialization
for compilers or linkers that have trouble compiling the default test runner.


Creating Test Runners from Parts
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The default behavior of +cxxtestgen+ is to generate a test runner
that directly integrates classes that define the tests along with
a +main()+ function that executes all test suites.  It is often useful to 
allow test suites to be processes separately and then linked together.  The +--root+ and +--part+ options
support this logic.  For example, suppose that we wish to define a test runner for tests in the headers
MyTestSuite1.h+ and +MyTestSuite2.h+.  We execute +cxxtestgen+ with the +--part+ option to generate source files for each of the test suites:
[source,bash]
----
include::examples/.buildRunner9_part.sh[]
----
Similarly, we execute +cxxtestgen+ with the +--root+ opiton to generate the +main()+ routine:
[source,bash]
----
include::examples/.buildRunner9_root.sh[]
----
Finally, the test runner is built by compiling all of these source files together:
[source,bash]
----
include::examples/.buildRunner9_compile.sh[]
----


Template Files
~~~~~~~~~~~~~~

CxxTest supports the use of _template files_ to provide a custom
main()+ function.  This may be useful when using a custom test
listener, or when using an existing CxxTest test listener in a
nonstandard manner.  A template file is an ordinary source files
with the embedded declaration +<CxxTest world>+, which tells
cxxtestgen+ to insert the world definition at that point.

The +--template+ option is used to specify the use of a template file:
[source,bash]
----
include::examples/.buildRunner10_main.sh[]
----
For example, consider the following template file:
[source,cplusplus]
----
include::examples/runner10.tpl[]
----
This file specifies macros that customize the test runner, and output is generated before and after the tests are run.

Note that CxxTest needs to insert certain definitions and +#include+
directives in the runner file. It normally does that before the
first +#include <cxxtest/*.h>+ found in the template file. If this
behavior is not what you need, use the directive +<CxxTest preamble>+
to specify where this preamble is inserted.


Test Discovery Options
~~~~~~~~~~~~~~~~~~~~~~

The +cxxtestgen+ command performs test discovery by searching C++
header files for CxxTest test classes.  The default process for
test discovery is a simple process that analyzes each line in a
header file sequentially, looking for a sequence of lines that
represent class definitions and test method definitions.

There are many limitations to this simple process for test discovery,
and in CxxTest 4.0 a new test discovery mechanism was added based
on the a parser for the
http://www.computing.surrey.ac.uk/research/dsrg/fog/[Flexible Object
Generator (FOG)] language, which is a superset of C\++.  The grammar
for the FOG language was adapted to parse C++ header files to
identify class definitions and class inheritance relationships,
class and namespace nesting of declarations, and class methods.
This allows +cxxtestgen+ to identify test classes that are defined
with complex inheritance relationships.

The +--fog+ option is used to specify the use of the FOG parser for
test discovery.  Although the FOG parser is more powerful, the
simpler +cxxtestgen+ test discover process is the default because
the FOG parser is slower execute.  Additionally, the FOG parser
requires the installation of +ply+ and, for Python version 2.6,
+ordereddict+.  If these packages are not available, then the +--fog+
option is automatically disabled.

The following sections illustrate differences between these two test discovery mechanisms, along with
general limitations of the test discovery process.

===== Unexpected Test Suite Format

The default test discovery mechanism does a very simple analysis
of the input files, which can easily fail when test classes are not
formated in a standard manner.  For example, consider the following
test suite:
[source,cpp]
-----
include::examples/MyTestSuite4.h[]
----
This test suite is not recognized by the default test discovery
mechanism, but the FOG parser correctly parsers this file and
recognizes the test suite.  A variety of similar discovery failures
arise due to the simple process used by the test discovery mechanism.


===== Commenting Out Tests

Adding and disabling tests are two common steps in test development.
The process of test discovery makes adding tests very easy.  However,
disabling tests is somewhat more complicated.  Consider the following
header file, which defines four tests (three of which are disabled):
[source,cpp]
-----
include::examples/MyTestSuite3.h[]
----

The first is commented out with C\++-style comments, the second
test is commented out with C-style comments, and the third test is
named in a manner that is not recognized through test discovery
(i.e., it does not start with +test+).

The default test discovery mechanism only works with the first and
third methods for disabling tests, but the FOG parser works with
all three.  The FOG parser performs a complex, multi-line parse of
the source file, so it can identify multi-line C-style comments.

Note, however, that the use of C macros will not work:
[source,cpp]
-----
include::examples/BadTestSuite1.h[]
----
The +cxxtestgen+ discovery mechanisms do not perform a C preprocessing
step, since that would generally require using externally defined
preprocessing variable definitions.  


[[runner]]
Test Runner Syntax
------------------

The default behavior of the CxxTest test runner is to execute all
tests in all of the test suites that are linked into the runner.
However, CxxTest test runners process command line options that
allow individual tests and test suites to be selected.

For example, consider a test runner defined as follows:
[source,bash]
----
include::examples/.buildRunner13_main.sh[]
----
The +--help+ (+-h+) option can be used to print the command line options for a test runner.  The command
[verbatim]
----
include::examples/.buildRunner13_help.sh[]
----
generates the following output:
[verbatim]
----
include::examples/runner13.help.txt[]
----

The +--help-tests+ option is used to list all test suites that are defined in a test runner.  The command
[verbatim]
----
include::examples/.buildRunner13_helpTests.sh[]
----
generates the following output:
[verbatim]
----
include::examples/runner13.helpTests.txt[]
----
The first column is the test suite name, and the second column is the test name.

All tests in a test suite can be executed by simply specifying the test suite name.  For example
[verbatim]
----
include::examples/.buildRunner13_MyTestSuite2.sh[]
----
executes the tests in test suite +MyTestSuite2+:
[verbatim]
----
include::examples/runner13.MyTestSuite2.txt[]
----

Similarly, a single test can be executed by specifying the test suite followed by the test name.  For example
[verbatim]
----
include::examples/.buildRunner13_testMultiplication.sh[]
----
executes the +testMultiplication+ test in test suite +MyTestSuite2+:
[verbatim]
----
include::examples/runner13.testMultiplication.txt[]
----

The +-v+ option enables the printing of trace information generated
by the +TS_TRACE+ function.  For example, the +testMultiplication+ test contains trace declarations
before and after the multiplication test.  Thus, the command
[verbatim]
----
include::examples/.buildRunner13_testMultiplicationVerbose.sh[]
----
generates this trace output before and after the test:
[verbatim]
----
include::examples/runner13.testMultiplicationVerbose.txt[]
----


[[advanced]]
Advanced Testing Features
-------------------------

Macros
~~~~~~

CXXTEST_STD
...


Customizing Test Fixtures
~~~~~~~~~~~~~~~~~~~~~~~~~

CxxTest test fixtures can be customized in several ways to manage
the environment for test suites and individual tests.  A common
feature of test suites is that they share a common logic for setting
up data used in the tests.  Thus, there may be duplicate code for
creating objects, files, inputs, etc.  Similarly, the tests may
share common logic for cleaning up after the test is finished (e.g. deleting temporary objects).

You can put this shared code in a common place by overriding the
virtual functions `TestSuite::setUp()` and `TestSuite::tearDown()`.
The `setUp()` function is called before each test, and `tearDown()`
is called after each test.

For example, the following test suite employs +setUp()+ and +tearDown()+ methods to 
allocate and deallocate memory for a string buffer:
[source,cpp]
-----
include::examples/MyTestSuite5.h[]
-----

If you need a fixture on the test suite level, i.e. something that gets
constructed once before all the tests in the test suite are run, see
<<dynamic,Dynamically creating test suites>> below.


[[samples]]
Sample Problems
---------------

CxxTest comes with some samples in the `sample/` subdirectory of
the distribution.  If you look in that directory, you will see three
Makefiles: `Makefile.unix`, `Makefile.msvc` and
`Makefile.bcc32` which are for Linux/Unix, MS Visual C\++ and
Borland C\++, repectively.  These files are provided as a starting point,
and some options may need to be tweaked in them for your system.

If you are running under Windows, a good guess would be to run
`nmake -fMakefile.msvc run_win32` (you may need to run
`VCVARS32.BAT` first).

Under Linux, `make -fMakefile.unix run_x11` should probably work.


[[installation]]
Installation
------------

TODO


[[discussion]]
Status and Future Plans
-----------------------

The CxxTest 4.0 release reflects major changes in the management
and focus of CxxTest.  The 4.0 release is the first release of
CxxTest in over seven years, and virtually all of the initial
developers have moved on to other projects.  CxxTest is heavily
used at Sandia National Laboratories, and Sandia's ongoing use of
CxxTest is a major driver for the 4.0 release.  Similarly, major
changes in CxxTest reflect the focus of the developer team:

 - Perl is no longer used to support CxxTest scripts.  Python is now the only scripting language used by CxxTest.
 - The testing scripts have been rewritten using the PyUnit framework.
 - The installation process for CxxTest now leverages and integrates with the system Python installation.
 - A more comprehensive C++ parser is now available, which supports testing of templates.
 - The CxxTest GUI is no longer supported, and the <<ts_warn,TS_WARN>> is deprecated.
 - CxxTest runners now have a command-line interface that facilitates interative use of the test runner.
 - A new user guide is now available in PDF, HTML and Ebook formats.

Additionally, CxxTest is now validated with continuous integration
tests.  Yes, the CxxTest developers eat their own dog food!

Although the GUI option for +cxxtestgen+ appears to work fine, this
GUI is rather primitive.  It simply provides a visual summary of
the test results, and not the interactive test execution that a
user would expect.  This capability is deprecated since none of the
current developers use this feature.  CxxTest users should consider
using CxxTest with http://jenkins-ci.org/[Jenkins].  The +XUnitPrinter+
test listener generates XML files that can be easily integrated by
http://jenkins-ci.org/[Jenkins], which creates a visual summary of
test results with links to drill-down into test outputs.

Discuss support for ...

 - embedded compilers...  (Macros vs templates)
 - SCONS
 - Python 3.0

This documentation has highlighted the commonly used test listeners.
There are a variety of other test listeners provided by CxxTest
that support advanced Cxxtest applications.  For example, the +YesNoRunner+ is
perhaps the simplest test listener;  it simply returns the number
of test failures.  The +StdioFilePrinter+ is used by +StdioPrinter+,
but it does not assume that +stdio+ is the default output stream.  This test listener can be used
in contexts where a custom output stream must be specified.

Future work:

 - ply cpp
 - ignore template test classes using the FOG parser


:numbered!:

[[acknowledgements]] 
Acknowledgements
----------------

TODO

ply
FOG grammar

[appendix]
[[appendix_A]] 
Test Assertion Examples
-----------------------

[[ts_assert]] TS_ASSERT::
This is the most basic test assertion, which simply verifies that the +_expr_+ argument is true:
[source,cplusplus]
----
include::examples/.Assertions_assert.h[]
----
[[ts_assert_delta]] TS_ASSERT_DELTA::
This test assertion verifies two floating point values are within a specified absolute difference:
[source,cplusplus]
----
include::examples/.Assertions_assertDelta.h[]
----

[[ts_assert_differs]] TS_ASSERT_DIFFERS::
This test assertion verifies that the two arguments are not equal:
[source,cplusplus]
----
include::examples/.Assertions_assertDiffers.h[]
----

[[ts_assert_equals]] TS_ASSERT_EQUALS::
  This test assertion verifies that the two arguments are equal:
[source,cplusplus]
----
include::examples/.Assertions_assertEquals.h[]
----
Note that this test is performed using the C++ +_==_+ operator, whose behavior may be redefined for the two argument types.

[[ts_assert_less_than]] TS_ASSERT_LESS_THAN::
This test assertion verifies that the first argument is strictly less than the second argument:
[source,cplusplus]
----
include::examples/.Assertions_assertLessThan.h[]
----

[[ts_assert_less_than_equals]] TS_ASSERT_LESS_THAN_EQUALS::
This test assertion verifies that the first argument is less than or equal to the second argument:
[source,cplusplus]
----
include::examples/.Assertions_assertLessThanEquals.h[]
----

[[ts_assert_predicate]] TS_ASSERT_PREDICATE::
This test assertion takes as an argument the name of a class, similar to a STL +_unary_function_+, and evaluates the +_operator()_+ method:
[source,cplusplus]
----
include::examples/.Assertions_assertPredicate.h[]
----
This test assertion can be seen as a generalization of <<ts_assert,TS_ASSERT>>, but it 
allows the tester to see the failed value. 

[[ts_assert_relation]] TS_ASSERT_RELATION::
It takes as an argument the name of a class, similar to a STL +_binary_function_+, and evaluates the +_operator()_+ method:
[source,cplusplus]
----
include::examples/.Assertions_assertRelation.h[]
----
This test assertion can be seen as a generalization of <<ts_assert_equals,TS_ASSERT_EQUALS>>, <<ts_assert_differs,TS_ASSERT_DIFFERS>>, <<ts_assert_less_than,TS_ASSERT_LESS_THAN>> and <<ts_assert_less_than_equals,TS_ASSERT_LESS_THAN_EQUALS>>. 
This can be used to assert comparisons which are not covered by the builtin test assertions. 

[[ts_assert_same_data]] TS_ASSERT_SAME_DATA::
This test assertion is similar to <<ts_assert_equals,TS_ASSERT_EQUALS>>,
except that it compares the contents of two buffers in memory:
[source,cplusplus]
----
include::examples/.Assertions_assertSameData.h[]
----
The standard runner dumps the contents of both buffers as hex values when this test fails.

[[ts_assert_throws]] TS_ASSERT_THROWS::
This test assertion verifies that the specified exception is thrown when the first argument is executed:
[source,cplusplus]
----
include::examples/.Assertions_assertThrows.h[]
----

[[ts_assert_throws_anything]] TS_ASSERT_THROWS_ANYTHING::
This test assertion verifies that _some_ exception is thrown when the first argument is executed:
[source,cplusplus]
----
include::examples/.Assertions_assertThrowsAnything.h[]
----

[[ts_assert_throws_assert]] TS_ASSERT_THROWS_ASSERT::
This test assertion verifies that an exception is thrown when executing the first argument.  The second argument specifies a variable declaration for the exception, and the third argument is executed to test that 
exception value:
[source,cplusplus]
----
include::examples/.Assertions_assertThrowsAssert.h[]
----
Note that this can be viewed as a generalization of <<ts_assert_throws_equals,TS_ASSERT_THROWS_EQUALS>>.

[[ts_assert_throws_equals]] TS_ASSERT_THROWS_EQUALS::
This test assertion verifies that an exception is thrown when executing the first argument.  The second argument specifies a variable declaration for the exception, and the third and fourth arguments are values that are asserted equal after the exception is thrown:
[source,cplusplus]
----
include::examples/.Assertions_assertThrowsEquals.h[]
----

[[ts_assert_throws_nothing]] TS_ASSERT_THROWS_NOTHING::
This test assertion verifies that an exception is _not_ thrown when executing the first argument:
[source,cplusplus]
----
include::examples/.Assertions_assertThrowsNothing.h[]
----

[[ts_fail]] TS_FAIL::
This function triggers a test failure with an associated message:
[source,cplusplus]
----
include::examples/.Assertions_fail.h[]
----

[[ts_trace]] TS_TRACE::
This function prints an informational message:
[source,cplusplus]
----
include::examples/.Assertions_trace.h[]
----

[[ts_warn]] TS_WARN::
This function prints a message as a warning:
[source,cplusplus]
----
include::examples/.Assertions_warn.h[]
----


[appendix]
[[appendix_B]] 
Integrating with Your Build Environment
---------------------------------------

It's very hard to maintain your tests if you have to generate,
compile and run the test runner manually all the time.
Fortunately, that's why we have build tools!

==== Overview

Let's assume you're developing an application.
What I usually do is the following:

* Split the application into a library and a main module that just calls
  the library classes.
  This way, the test runner will be able to access all your classes through
  the library.
* Create another application (or target, or project, or whatever) for the test runner.
  Make the build tool generate it automatically.
* For extra points, make the build tool run the tests automatically.

==== Actually doing it

Unfortunately, there are way too many different build tools and IDE's for me 
to give ways to use CxxTest with all of them.

I will try to outline the usage for some cases.

===== Using Makefiles

Generating the tests with a makefile is pretty straightforward.
Simply add rules to generate, compile and run the test runner.

[source,makefile]
-----
all: lib run_tests app

# Rules to build your targets
lib: ...

app: ...

# A rule that runs the unit tests
run_tests: runner
        ./runner

# How to build the test runner
runner: runner.cpp lib
        g++ -o $@ $^

# How to generate the test runner
runner.cpp: SimpleTest.h ComplicatedTest.h
         cxxtestgen -o $@ --error-printer $^
-----

===== Using Cons

http://dsmit.com/cons/[Cons] is a powerful and 
versatile make replacement which uses Perl scripts instead of Makefiles.

See `sample/Construct` in the CxxTest distribution for an example of building CxxTest test runners
with Cons.

===== Using Microsoft Visual Studio

I have tried several ways to integrate CxxTest with visual studio, none of
which is perfect.  Take a look at `sample/msvc` in the distribution
to see the best solution I'm aware of.  Basically, the workspace has three
projects:

* The project `CxxTest_3_Generate` runs `cxxtestgen`.
* The project `CxxTest_2_Build` compiles the generated file.
* The project `CxxTest_1_Run` runs the tests.

This method certainly works, and the test results are conveniently
displayed as compilation errors and warnings (for
{ts_warn}.  However, there are still a few things missing;
to integrate this approach with your own project, you usually need to
work a little bit and tweak some makefiles and project options.  I have
provided a small script in `sample/msvc/FixFiles.bat` to automate
some of the process.

===== Using Microsoft Windows DDK

Unit testing for device drivers?!  Why not?
And besides, the `build` utility can also be used to build
user-mode application.

To use CxxTest with the `build` utility, 
you add the generated tests file as an extra dependency
using the `NTBUILDTARGET0` macro and the `Makefile.inc`
file.

You can see an example of how to do this in the CxxTest distribution
under `sample/winddk`.

:leveloffset: 1

[appendix]
[[appendix_C]] 
include::../Versions[]

:leveloffset: 0

// vim: set syntax=asciidoc:

